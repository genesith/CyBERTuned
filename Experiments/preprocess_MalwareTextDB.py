import glob
from random import sample
from collections import Counter

from preprocess import save_jsonl
import os
from consts import task2labels


# ActionName, Capability, StrategicObjectives, TacticalObjectives
def collect_real_attributes():
    rawfol = "raw_data"    
    attribute_label = {'ActionName': list(), 'Capability': list(), 'StrategicObjectives': list(), 'TacticalObjectives': list()}
    for data_type in ('train', 'dev', 'test_1', 'test_3'):
        rawpath = os.path.join(f"MalwareTextDB-2.0", f'data/{data_type}/annotations')
        
        for fpath in glob.glob(f'{os.path.join(rawfol, rawpath)}/*'):
            # fname = fpath.split('/')[-1]
            if '.ann' in fpath:
                with open(fpath) as f:
                    text = f.readlines()
                    for row in text:
                        row_ = row.split('\t')
                        # index = row_[0]
                        # Attribute
                        if 'A' in row_[0]:
                            attr_info = row_[1].split(' ')
                            attribute_label[attr_info[0]].append(attr_info[-1].replace('\n', ''))
    for k, v in attribute_label.items():
        attribute_label[k] = list(set(v))
    
def pick_answer_choices(attr_type, true_label, num_choices = 5):
    label_list = [label[4:] for label in task2labels['MalwareTextDB_New_labels'][attr_type] if label != true_label]
    samples = sample(sample(label_list, k=num_choices-1) + [true_label[4:]], k=num_choices)
    return samples


def preprocess_MalwareTextDB(rawpath, resultpath):
    if not os.path.exists(f"{resultpath}_New/"):
        os.mkdir(f"{resultpath}_New/")
    
    # Output jsonl object initialization
    jsonl_per_folder = {}
    for data_type in ['train', 'dev', 'test_1', 'test_2', 'test_3']:
        jsonl_new = []
        rawpath_ = os.path.join(f"{rawpath}-2.0", f'data/{data_type}/annotations')
        
        idx = 0 
        for ai, fname in enumerate(os.listdir(rawpath_)):
            if not '.ann' in fname:
                continue
            # Read article text
            with open(os.path.join(rawpath_, f"{'.'.join(fname.split('.')[:-1])}.txt")) as f:
                text = f.read()

            # Read annotation file
            with open(os.path.join(rawpath_, fname), 'r') as f:
                lines = [line.strip() for line in f]
            Ts = [a for a in lines if a[0] == 'T']
            Tindexes = {}
            for T in Ts:
                T_id, T_info, T_text = T.split("\t")
                Tindexes[T_id] = T_info
            As = [a for a in lines if a[0] == 'A']
 
            for A in As:
                tmp = A.split("\t")
                A_type, A_id, A_label = tmp[1].split(' ')
                
                choices = pick_answer_choices(A_type, A_label)
                answer = A_label[4:]

                offset_value = 400
                if ";" in Tindexes[A_id]:
                    _, span_start, _, span_end = Tindexes[A_id].split(' ')
                else:
                    _, span_start, span_end = Tindexes[A_id].split(' ')
                span_start = int(span_start)
                span_end = int(span_end)
                # look for a space to end it
                if 0 >span_start-offset_value:
                    prefix_start = 0
                elif " " in text[span_start-offset_value: span_start]:
                    prefix_start = text.index(' ', span_start-offset_value, span_start)
                elif "\xa0" in text[span_start-offset_value: span_start]:
                    prefix_start = text.index("\xa0", span_start-offset_value, span_start)
                else:
                    assert False
                    
                if span_end + offset_value >= len(text):
                    suffix_end = len(text)
                elif " " in text[span_end: span_end+offset_value]:
                    suffix_end = text.rindex(' ', span_end, span_end+offset_value)
                elif "\xa0" in text[span_end: span_end+offset_value]:
                    suffix_end = text.rindex("\xa0", span_end, span_end+offset_value)
                else:
                    assert False
                
                prefix_text = text[prefix_start: span_start]
                target_text = text[span_start:span_end]
                suffix_text = text[span_end: suffix_end]
                
                json_obj_new = {'article_idx': fname, 'idx': idx, 'prefix_text': prefix_text,
                                'target_text': target_text, 'suffix_text': suffix_text, 'choices': choices,
                                'label_text': answer, 'label':choices.index(answer), 'type': A_type}
                jsonl_new.append(json_obj_new)
                idx += 1
        jsonl_per_folder[data_type] = jsonl_new

    
    save_jsonl(f'{resultpath}_New/train.jsonl', jsonl_per_folder['train'])
    save_jsonl(f'{resultpath}_New/dev.jsonl', jsonl_per_folder['dev'])
    save_jsonl(f'{resultpath}_New/test.jsonl', jsonl_per_folder['test_1'] + jsonl_per_folder['test_2'] + jsonl_per_folder['test_3'])



if __name__ == '__main__':
    # collect_real_attributes()
    rawfol = 'raw_data'
    datafol = 'data'
    rawpath = os.path.join(rawfol,'MalwareTextDB')
    resultpath = os.path.join(datafol,'MalwareTextDB')
    preprocess_MalwareTextDB(rawpath, resultpath)
